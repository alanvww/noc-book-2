<section data-type="chapter">
<h1 id="chapter-1-vectors">Chapter 1. Vectors</h1>
<blockquote data-type="epigraph">
  <p>“Roger, Roger. What’s our vector, Victor?”</p>
  <p>— Captain Oveur (Airplane)</p>
</blockquote>
<p>This book is all about looking at the world around us and developing ways to simulate it with code. In this first part of the book, I’ll start by looking at basic physics: how an apple falls from a tree, how a pendulum swings in the air, how Earth revolves around the sun, and so on. Absolutely everything contained within the book’s first five chapters requires the use of the most basic building block for programming motion, the <strong><em>vector</em></strong>. And so that’s where I’ll begin the story.</p>
<p>The word <em>vector</em> can mean a lot of different things. It’s the name of a New Wave rock band formed in Sacramento, California, in the early 1980s, and the name of a breakfast cereal manufactured by Kellogg’s Canada. In the field of epidemiology, a vector is an organism that transmits infection from one host to another. In the C++ programming language, a vector (<code>std::vector</code>) is an implementation of a dynamically resizable array data structure.</p>
<p>While all these definitions are worth exploring, they’re not the focus here. Instead, this chapter dives into the <strong><em>Euclidean vector</em></strong> (named for the Greek mathematician Euclid), also known as the <strong><em>geometric vector</em></strong>. When you see the term <em>vector</em> in this book, you can assume it refers to a Euclidean vector, defined as <em>an entity that has both magnitude and direction</em>.</p>
<figure class="half-width-left">
  <img src="images/01_vectors/01_vectors_1.png" alt=" Figure 1.1: A vector represented as an arrow drawn from point A to point B.">
  <figcaption>Figure 1.1: A vector represented as an arrow drawn from point A to point B.</figcaption>
</figure>
<p>A vector is typically drawn as an arrow, as in Figure 1.1. The vector’s direction is indicated by where the arrow is pointing, and its magnitude by the length of the arrow itself.</p>
<p>The vector in Figure 1.1 is drawn as an arrow from point A to point B. It serves as an instruction for how to travel from A to B.</p>
<h2 id="11-vectors-you-complete-me">1.1 Vectors, You Complete Me</h2><a data-type="indexterm" data-primary="bouncing ball sketch"></a><a data-type="indexterm" data-primary="vectors" data-secondary="bouncing ball sketch"></a>
<p>Before diving into more of the details about vectors, I’d like to create a p5.js example that demonstrates why you should care about vectors in the first place. If you’ve watched any beginner p5.js tutorials, read any introductory p5.js textbooks, or taken an introduction to creative coding course (and hopefully you’ve done one of these things to help prepare you for this book!), you probably, at one point or another, learned how to write a bouncing ball sketch.</p>
<div data-type="example">
  <h3 id="example-11-bouncing-ball-with-no-vectors">Example 1.1: Bouncing Ball with No Vectors</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/oadKdOndU" data-example-path="examples/01_vectors/example_1_1_bouncing_ball_with_no_vectors"><img src="examples/01_vectors/example_1_1_bouncing_ball_with_no_vectors/screenshot.png"></div>
    <figcaption>If you are reading this book as a PDF or in print, then you will only see screenshots of the canvas. Motion, of course, is a key element of the discussion, so to the extent possible, the static screenshots will include trails to give a sense of the behavior. For more about how to draw trails, see the code examples linked from the website.</figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">// Variables for position and speed of ball.
let x = 100;
let y = 100;
let xspeed = 1;
let yspeed = 3.3;

//{!4} Remember how p5 works? setup() is executed once when the sketch starts and draw() loops forever and ever (until you quit).
function setup() {
  createCanvas(640, 240);
  background(255);
}

function draw() {
  background(255);

  // Move the ball according to its speed.
  x = x + xspeed;
  y = y + yspeed;

  //{!6} Check for bouncing.
  if ((x > width)  || (x &#x3C; 0)) {
    xspeed = xspeed * -1;
  }
  if ((y > height) || (y &#x3C; 0)) {
    yspeed = yspeed * -1;
  }

  stroke(0);
  fill(175);
  //{!1} Draw the ball at the position (x,y).
  circle(x, y, 48);
}</pre>
<p>In this example, there’s a flat, two-dimensional world—a blank canvas—with a circular shape (a “ball”) traveling around. This ball has properties like position and speed that are represented in the code as variables.</p>
<table>
  <tbody>
    <tr>
      <td>position</td>
      <td><code>x</code> and <code>y</code></td>
    </tr>
    <tr>
      <td>speed</td>
      <td><code>xspeed</code> and <code>yspeed</code></td>
    </tr>
  </tbody>
</table>
<p>In a more sophisticated sketch, you might have many more variables representing other properties of the ball and its environment:</p>
<table>
  <tbody>
    <tr>
      <td>acceleration</td>
      <td><code>xacceleration</code> and <code>yacceleration</code></td>
    </tr>
    <tr>
      <td>target position</td>
      <td><code>xtarget</code> and <code>ytarget</code></td>
    </tr>
    <tr>
      <td>wind</td>
      <td><code>xwind</code> and <code>ywind</code></td>
    </tr>
    <tr>
      <td>friction</td>
      <td><code>xfriction</code> and <code>yfriction</code></td>
    </tr>
  </tbody>
</table>
<p>You might notice that for every concept in this world (wind, position, acceleration, and the like), there are two variables. And this is only a two-dimensional world. In a 3D world, you’d need three variables for each property: <code>x</code>, <code>y</code>, and <code>z</code> for position, <code>xspeed</code>, <code>yspeed</code>, and <code>zspeed</code> for speed, and so on. Wouldn’t it be nice to simplify the code to use fewer variables? Instead of starting the program with something like this:</p>
<pre class="codesplit" data-code-language="javascript">let x;
let y;
let xspeed;
let yspeed;</pre>
<p>I’d love to start it with something like this:</p>
<pre class="codesplit" data-code-language="javascript">let position;
let speed;</pre>
<p>Thinking of the ball’s properties as vectors instead of a loose collection of separate values will allow me to do just that.</p>
<p>Taking this first step toward using vectors won’t let you do anything new or magically turn a p5.js sketch into a full-on physics simulation. However, using vectors will help organize your code and provide a set of functions for common mathematical operations you’ll need over and over and over again while programming motion.</p>
<p>As an introduction to vectors, I’m going to stick to two dimensions for quite some time (at least the first several chapters). All of these examples can be fairly easily extended to three dimensions (and the class I’ll use, <code>p5.Vector</code>, allows for three dimensions). However, for the purposes of learning the fundamentals, the added complexity of the third dimension would be a distraction.</p>
<h2 id="12-vectors-in-p5js">1.2 Vectors in p5.js</h2><a data-type="indexterm" data-primary="Processing" data-secondary="vectors and"></a><a data-type="indexterm" data-primary="PVector class (Processing)"></a><a data-type="indexterm" data-primary="vectors" data-secondary="Processing and"></a>
<p>Think of a vector as the difference between two points, or as instructions for walking from one point to another. For example, Figure 1.2 shows some vectors and possible interpretations of them.</p>
<figure>
  <img src="images/01_vectors/01_vectors_2.png" alt="Figure 1.2: Three example vectors drawn as arrows, with accompanying instructions for walking in north, south, east, or west directions">
  <figcaption>Figure 1.2: Three example vectors drawn as arrows, with accompanying instructions for walking in north, south, east, or west directions</figcaption>
</figure>
<p>These vectors translate as follows:</p>
<table>
  <tbody>
    <tr>
      <td>(-15, 3)</td>
      <td>Walk fifteen steps west; turn and walk three steps north.</td>
    </tr>
    <tr>
      <td>(3, 4)</td>
      <td>Walk three steps east; turn and walk four steps north.</td>
    </tr>
    <tr>
      <td>(2, -1)</td>
      <td>Walk two steps east; turn and walk one step south.</td>
    </tr>
  </tbody>
</table>
<p>You’ve probably already thought this way when programming motion. For every frame of animation (a single cycle through p5’s <code>draw()</code> loop), you instruct each object to move a certain number of pixels horizontally and a certain number of pixels vertically in a canvas. This instruction is essentially a vector, as in Figure 1.3; it has both magnitude (the number of steps) and direction (some combination of horizontal and vertical).</p>
<figure>
  <img src="images/01_vectors/01_vectors_3.png" alt="Figure 1.3: A vector showing the number of horizontal and vertical steps to go from a position to a “new” position.">
  <figcaption>Figure 1.3: A vector showing the number of horizontal and vertical steps to go from a position to a “new” position.</figcaption>
</figure>
<p>The vector sets the object’s <strong><em>velocity</em></strong>, defined as the rate of change of the object’s position. In other words, the velocity vector determines the object’s new position for every frame of the animation, according to this basic algorithm for motion:</p>
<p><strong><em>new position = velocity applied to current position</em></strong></p><a data-type="indexterm" data-primary="positions" data-secondary="as vectors"></a><a data-type="indexterm" data-primary="vectors" data-secondary="positions and"></a><a data-type="indexterm" data-primary="vectors" data-secondary="velocity and"></a><a data-type="indexterm" data-primary="velocity" data-secondary="as vector"></a>
<p>If velocity is a vector (the difference between two points), what about position? Is it a vector too? Technically, you could argue that position is not a vector, since it’s not describing how to move from one point to another—it’s describing a single point in space. Nevertheless, another way to describe a position is as the path taken from the origin—point (0,0)—to the current point. When you think of position in this way, it becomes a vector, just like velocity, as in Figure 1.4.</p>
<figure>
  <img src="images/01_vectors/01_vectors_4.png" alt="Figure 1.4: A computer graphics window with (0,0) in the top left, showing a position vector and a velocity vector">
  <figcaption>Figure 1.4: A computer graphics window with (0,0) in the top left, showing a position vector and a velocity vector</figcaption>
</figure>
<p>In Figure 1.4, the vectors are placed in a computer graphics canvas. Unlike in Figure 1.2, the origin point (0,0) isn’t the center, it’s the top-left corner. And instead of north, south, east, and west, there are positive and negative directions along the x- and y-axes (with y pointing down in the positive direction).</p>
<p>Let’s examine the underlying data for both position and velocity. In the bouncing ball example, I originally had the following variables:</p>
<table>
  <tbody>
    <tr>
      <td>position</td>
      <td><code>x</code>, <code>y</code></td>
    </tr>
    <tr>
      <td>velocity</td>
      <td><code>xspeed</code>, <code>yspeed</code></td>
    </tr>
  </tbody>
</table>
<p>Now I’ll treat position and velocity as vectors instead, each represented by an object with <code>x</code> and <code>y</code> attributes. If I were to write a <code>Vector</code> class myself, I’d start with something like this:</p>
<pre class="codesplit" data-code-language="javascript">class Vector {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}</pre>
<p>Notice how this class is designed to store the same data as before—two floating-point numbers per vector, an <code>x</code> value and a <code>y</code> value. At its core, a <code>Vector</code> object is just a convenient way to store two values (or three, as you’ll see in 3D examples) under one name.</p>
<p>As it happens, p5.js already has a built-in <code>p5.Vector</code> class, so I don’t need to write one myself. And so this . . .</p>
<pre class="codesplit" data-code-language="javascript">let x = 100;
let y = 100;
let xspeed = 1;
let yspeed = 3.3;</pre>
<p>becomes . . .</p>
<pre class="codesplit" data-code-language="javascript">let position = createVector(100, 100);
let velocity = createVector(1, 3.3);</pre>
<p>Notice that the <code>position</code> and <code>velocity</code> vector objects aren’t created, as you might expect, by invoking a constructor function. Instead of writing <code>new p5.Vector(x, y)</code>, I’ve called <code>createVector(x, y)</code>. The <code>createVector()</code> function is included in p5.js as a helper function to take care of details behind the scenes upon creation of the vector. Except in special circumstances, you should always create <code>p5.Vector</code> objects with <code>createVector()</code>.</p><a data-type="indexterm" data-primary="vectors" data-secondary="motion" data-tertiary="implementing with"></a>
<p>Now that there are two vector objects (<code>position</code> and <code>velocity</code>), I’m ready to implement the vector-based algorithm for motion: <strong><em>position = position + velocity</em></strong>. In Example 1.1, without vectors, the code read:</p>
<pre class="codesplit" data-code-language="javascript">// Add each speed to each position.
x = x + xspeed;
y = y + yspeed;</pre>
<p>In an ideal world, I would be able to rewrite this as:</p>
<pre class="codesplit" data-code-language="javascript">// Add the velocity vector to the position vector.
position = position + velocity;</pre><a data-type="indexterm" data-primary="addition operator"></a>
<p>In JavaScript, however, the addition operator <code>+</code> is reserved for primitive values (integers, floats, and the like). JavaScript doesn’t know how to add two <code>p5.Vector</code> objects together any more than it knows how to add two <code>p5.Font</code> objects or <code>p5.Image</code> objects. Fortunately, the <code>p5.Vector</code> class includes functions for common mathematical operations.</p>
<h2 id="13-vector-addition">1.3 Vector Addition</h2><a data-type="indexterm" data-primary="add() function (PVector class)"></a><a data-type="indexterm" data-primary="vectors" data-secondary="adding"></a>
<p>Before I continue looking at the <code>p5.Vector</code> class and the <code>add()</code> method, let’s examine vector addition using the notation found in math and physics textbooks. Vectors are typically written either in boldface type or with an arrow on top. For the purposes of this book, to distinguish a <strong><em>vector</em></strong> (with magnitude and direction) from a <strong><em>scalar</em></strong> (a single value, such as an integer or a floating-point number), I’ll use the arrow notation:</p><a data-type="indexterm" data-primary="scalar notation" data-secondary="vs. vector notation"></a><a data-type="indexterm" data-primary="vector notation" data-secondary="vs. scalar notation"></a>
<ul>
  <li>Vector: <span data-type="equation">\vec{v}</span></li>
  <li>Scalar: <span data-type="equation">{x}</span></li>
</ul>
<p>Let’s say I have the two vectors shown in Figure 1.5.</p>
<figure>
  <img src="images/01_vectors/01_vectors_5.png" alt="Figure 1.5: Two vectors  
\vec{u} and \vec{v} depicted as triangles with components (5,2) and (3,4)">
  <figcaption>Figure 1.5: Two vectors <span data-type="equation">\vec{u}</span> and <span data-type="equation">\vec{v}</span> depicted as triangles with components (5,2) and (3,4)</figcaption>
</figure>
<p>Each vector has two components, an <span data-type="equation">x</span> and a <span data-type="equation">y</span>. To add the two vectors together, add both <span data-type="equation">x</span> components and <span data-type="equation">y</span> components to create a new vector, as in Figure 1.6.</p>
<figure>
  <img src="images/01_vectors/01_vectors_6.png" alt="Figure 1.6: Addition of vectors by adding the x and y components together.">
  <figcaption>Figure 1.6: Addition of vectors by adding the x and y components together.</figcaption>
</figure>
<p>In other words, <span data-type="equation">\vec{w} = \vec{u} + \vec{v}</span> can be written as:</p>
<div data-type="equation">w_x = u_x + v_x</div>
<div data-type="equation">w_y = u_y + v_y</div>
<p>Then, replacing <span data-type="equation">\vec{u}</span> and <span data-type="equation">\vec{v}</span> with their values from Figure 1.6, you get:</p>
<div data-type="equation">w_x = 5 + 3 = 8</div>
<div data-type="equation">w_y = 2 + 4 = 6</div>
<p>Finally, write the result as a vector:</p>
<div data-type="equation">\vec{w} = (8,6)</div>
<div data-type="note">
  <h3 id="addition-properties-with-vectors">Addition Properties with Vectors</h3>
  <p>Addition with vectors follows the same algebraic rules as with real numbers.</p>
  <p><strong><em>The commutative rule:</em></strong> <span data-type="equation">\vec{u} + \vec{v} = \vec{v} + \vec{u}</span></p>
  <p><strong><em>The associative rule:</em></strong> <span data-type="equation">\vec{u} + (\vec{v} + \vec{w}) = (\vec{u} + \vec{v}) + \vec{w}</span></p>
  <p>Fancy terminology and symbols aside, these rules boil down to quite a simple concept: the result is the same no matter the order in which the vectors are added. Replace the vectors with regular numbers (scalars) and these rules are easy to see:</p>
  <div data-type="equation">3 + 2 = 2 + 3</div>
  <div data-type="equation">(3 + 2) + 1 = 3 + (2 + 1)</div>
</div><a data-type="indexterm" data-primary="add() function (PVector class)" data-secondary="implementation of"></a>
<p>Now that I’ve covered the theory behind adding two vectors together, I can turn to adding vector objects in p5.js. Imagine again that I’m creating my own <code>Vector</code> class. I could give it a function called <code>add()</code> that takes another <code>Vector</code> object as its argument:</p>
<pre class="codesplit" data-code-language="javascript">class Vector {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  //{!4 .bold} New! A function to add another Vector to this Vector. Add the <em>x</em> components and the <em>y</em> components separately.
  add(v) {
    this.y = this.y + v.y;
    this.x = this.x + v.x;
  }
}</pre><a data-type="indexterm" data-primary="bouncing ball sketch" data-secondary="implementing with vectors"></a>
<p>The function looks up the <code>x</code> and <code>y</code> components of the two vectors and adds them separately. This is exactly how the built-in <code>p5.Vector</code> class’s <code>add()</code> function is written, too. Knowing how it works, I can now return to the bouncing ball example with its <strong><em>position + velocity</em></strong> algorithm and implement vector addition:</p>
<pre class="codesplit" data-code-language="javascript">//{!1 .line-through} This does not work!
position = position + velocity;
//{!1} Add the velocity to the position.
position.add(velocity);</pre>
<p>Now we have what we need to rewrite the bouncing ball example with vectors.</p><a data-type="indexterm" data-primary="dot syntax"></a><a data-type="indexterm" data-primary="object-oriented programming" data-secondary="dot syntax"></a>
<div data-type="example">
  <h3 id="example-12-bouncing-ball-with-vectors">Example 1.2: Bouncing ball with vectors!</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/qU5oPJijX" data-example-path="examples/01_vectors/example_1_2_bouncing_ball_with_vectors"><img src="examples/01_vectors/example_1_2_bouncing_ball_with_vectors/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">//{!2 .bold} Instead of a bunch of floats, we now just have two variables.
let position;
let velocity;

function setup() {
  createCanvas(640, 240);
  //{!2 .bold .no-comment}
  position = createVector(100, 100);
  velocity = createVector(2.5, 5);
}

function draw() {
  background(255);
  //{!1 .bold .no-comment}
  position.add(velocity);

  //{!6 .bold .code-wide} We still sometimes need to refer to the individual components of a p5.Vector and can do so using the dot syntax: position.x, velocity.y, etc.
  if ((position.x > width) || (position.x &#x3C; 0)) {
    velocity.x = velocity.x * -1;
  }
  if ((position.y > height) || (position.y &#x3C; 0)) {
    velocity.y = velocity.y * -1;
  }

  stroke(0);
  fill(175);
  circle(position.x, position.y, 48);
}</pre>
<p>At this stage, you might feel somewhat disappointed. After all, these changes may appear to have made the code more complicated than the original version. While this is a perfectly reasonable and valid critique, it’s important to understand that the power of programming with vectors hasn’t been fully realized just yet. Looking at a bouncing ball and only implementing vector addition is just the first step. As I move forward into a more complex world of multiple objects and multiple <strong><em>forces</em></strong> (which I’ll introduce in Chapter 2) acting on those objects, the benefits of vectors will become more apparent.</p>
<p>I should, however, note an important aspect of the transition to programming with vectors. Even though I’m using <code>p5.Vector</code> objects to encapsulate two values—the <code>x</code> and <code>y</code> of the ball’s position or the <code>x</code> and <code>y</code> of the ball’s velocity—under a single variable name, I’ll still often need to refer to the <code>x</code> and <code>y</code> components of each vector individually. For example, when I go to draw an object in p5.js, I can’t write:</p>
<pre class="codesplit" data-code-language="javascript">//{.line-through .no-comment}
circle(position, 48);</pre>
<p>The <code>circle()</code> function doesn’t allow for a <code>p5.Vector</code> object as an argument. A circle can only be drawn with two scalar values, an x-coordinate and a y-coordinate. And so I must dig into the <code>p5.Vector</code> object and pull out the <code>x</code> and <code>y</code> components using object-oriented dot syntax:</p>
<pre class="codesplit" data-code-language="javascript">circle(position.x, position.y, 48);</pre>
<p>The same issue arises when testing if the circle has reached the edge of the window. In this case, I need to access the individual components of both vectors, <code>position</code> and <code>velocity</code>:</p>
<pre class="codesplit" data-code-language="javascript">if ((position.x > width) || (position.x &#x3C; 0)) {
  velocity.x = velocity.x * -1;
}</pre>
<div data-type="exercise">
  <h3 id="exercise-11">Exercise 1.1</h3>
  <p>Find something you’ve previously made in p5.js using separate <code>x</code> and <code>y</code> variables, and use vectors instead.</p>
</div>
<div data-type="exercise">
  <h3 id="exercise-12">Exercise 1.2</h3>
  <p>Take one of the walker examples from the Introduction and convert it to use vectors.</p>
</div>
<div data-type="exercise">
  <h3 id="exercise-13">Exercise 1.3</h3>
  <p>Extend the bouncing ball with vectors example into 3D. Can you get a sphere to bounce around a box?</p>
</div>
<h2 id="14-more-vector-math">1.4 More Vector Math</h2>
<p>Addition was really just the first step. There are many mathematical operations commonly used with vectors. Here’s a comprehensive list of the operations available as functions in the <code>p5.Vector</code> class:</p><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="mathematical functions for"></a><a data-type="indexterm" data-primary="angleBetween() function (PVector class)"></a><a data-type="indexterm" data-primary="cross() function (PVector class)"></a><a data-type="indexterm" data-primary="dist() function (PVector class)"></a><a data-type="indexterm" data-primary="dot() function (PVector class)"></a><a data-type="indexterm" data-primary="heading() function (PVector class)"></a><a data-type="indexterm" data-primary="lerp() function (PVector class)"></a><a data-type="indexterm" data-primary="limit() function (PVector class)"></a><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="function list for"></a><a data-type="indexterm" data-primary="random2D() function (PVector class)"></a><a data-type="indexterm" data-primary="random3D() function (PVector class)"></a><a data-type="indexterm" data-primary="rotate() function (PVector class)"></a>
<ul>
  <li><code>add()</code> — add vectors</li>
  <li><code>sub()</code> — subtract vectors</li>
  <li><code>mult()</code> — scale the vector with multiplication</li>
  <li><code>div()</code> — scale the vector with division</li>
  <li><code>mag()</code> — calculate the magnitude of a vector</li>
  <li><code>setMag()</code> — set the magnitude of a vector</li>
  <li><code>normalize()</code> — normalize the vector to a unit length of 1</li>
  <li><code>limit()</code> — limit the magnitude of a vector</li>
  <li><code>heading()</code> — the 2D heading of a vector expressed as an angle</li>
  <li><code>rotate()</code> — rotate a 2D vector by an angle</li>
  <li><code>lerp()</code> — linear interpolate to another vector</li>
  <li><code>dist()</code> — the Euclidean distance between two vectors (considered as points)</li>
  <li><code>angleBetween()</code> — find the angle between two vectors</li>
  <li><code>dot()</code> — the dot product of two vectors</li>
  <li><code>cross()</code> — the cross product of two vectors (only relevant in three dimensions)</li>
  <li><code>random2D()</code> — make a random 2D vector</li>
  <li><code>random3D()</code> — make a random 3D vector</li>
</ul>
<p>I’ll go through a few of the key functions now. As the examples get more sophisticated in later chapters, I’ll continue to reveal the details of more of them.</p>
<h3 id="vector-subtraction">Vector Subtraction</h3>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_7.png" alt="Figure 1.7: Showing the relationship between \vec{v} and -\vec{v} ">
  <figcaption>Figure 1.7: Showing the relationship between <span data-type="equation">\vec{v}</span> and <span data-type="equation">-\vec{v}</span> </figcaption>
</figure>
<p>Having already covered addition, I’ll now turn to subtraction. This one’s not so bad; just take the plus sign and replace it with a minus! Before tackling subtraction itself, however, consider what it means for a vector <span data-type="equation">\vec{v}</span> to become <span data-type="equation">-\vec{v}</span>. The negative version of the scalar 3 is -3. A negative vector is similar: the polarity of each of the vector’s components is inverted. So if <span data-type="equation">\vec{v}</span> has the components <span data-type="equation">(x, y)</span>, then <span data-type="equation">-\vec{v}</span> is <span data-type="equation">(-x, -y)</span>. Visually, this results in an arrow of the same length as the original vector pointing in the opposite direction, as depicted in Figure 1.7.</p><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="sub() function"></a><a data-type="indexterm" data-primary="sub() function (PVector class)"></a>
<p>Subtraction, then, is the same as addition, but we’re treating the second vector in the equation as a negative version of itself:</p>
<div data-type="equation">\vec{u} - \vec{v} = \vec{u} + -\vec{v}</div>
<p>Just as vectors are added by placing them end to end, vectors are subtracted by reversing the second arrow and placing it at the end of the first, as in Figure 1.8.</p>
<figure>
  <img src="images/01_vectors/01_vectors_8.png" alt="Figure 1.8 Showing vector subtraction as one vector placed at the end of another, but pointing in the opposite direction. ">
  <figcaption>Figure 1.8 Showing vector subtraction as one vector placed at the end of another, but pointing in the opposite direction.</figcaption>
</figure>
<p>To actually solve the subtraction, take the difference of the vectors’ components. That is, <span data-type="equation">\vec{w} = \vec{u} - \vec{v}</span> can be written as:</p>
<div data-type="equation">w_x = u_x - v_x</div>
<div data-type="equation">w_y = u_y - v_y</div>
<p>Inside <code>p5.Vector</code>, the code reads:</p>
<pre class="codesplit" data-code-language="javascript">sub(v) {
  this.x = this.x - v.x;
  this.y = this.y - v.y;
}</pre>
<p>The following example demonstrates vector subtraction by taking the difference between two points (that are treated as vectors): the mouse position and the center of the window.</p>
<div data-type="example">
  <h3 id="example-13-vector-subtraction">Example 1.3: Vector subtraction</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/HtXiElQbC" data-example-path="examples/01_vectors/example_1_3_vector_subtraction"><img src="examples/01_vectors/example_1_3_vector_subtraction/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">function draw() {
  background(255);
  //{!2} Two vectors, one for the mouse location and one for the center of the window
  let mouse  = createVector(mouseX, mouseY);
  let center = createVector(width / 2, height / 2);

  //{!3} Draw the original two vectors
  stroke(200);
  strokeWeight(4);
  line(0, 0, mouse.x, mouse.y);
  line(0, 0, center.x, center.y);

  // Vector subtraction!
  mouse.sub(center);

  //{!3} Draw a line to represent the result of subtraction.
  // Notice how I move the origin with translate() to place the vector
  stroke(0);
  translate(width/2, height/2);
  line(0, 0, mouse.x, mouse.y);
}</pre><a data-type="indexterm" data-primary="vectors" data-secondary="commutative" data-tertiary="associative rules of addition"></a>
<p>Note the use of <code>translate()</code> to visualize the resulting vector as a line from the center <code>(width/2, height/2</code>) to the mouse. Otherwise the line would be drawn from the top-left corner and might fall outside the canvas.</p>
<h3 id="vector-multiplication-and-division">Vector Multiplication and Division</h3><a data-type="indexterm" data-primary="mult() function (PVector class)"></a><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="mult() function"></a><a data-type="indexterm" data-primary="vectors" data-secondary="multiplying"></a><a data-type="indexterm" data-primary="vectors" data-secondary="scaling"></a>
<p>Moving on to multiplication, you have to think a bit differently. Multiplying a vector typically refers to the process of <strong><em>scaling</em></strong> a vector. If I want to scale a vector to twice its size or one-third of its size, while leaving its direction the same, I would say: “Multiply the vector by 2” or “Multiply the vector by 1/3.” Unlike with addition and subtraction, I’m multiplying the vector by a scalar (a single number), not by another vector. Figure 1.9 illustrates how to scale a vector by a factor of 3.</p>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_9.png" alt="Figure 1.9 Scaling a vector with multiplication">
  <figcaption>Figure 1.9 Scaling a vector with multiplication</figcaption>
</figure>
<p>To scale a vector, multiply each component (<span data-type="equation">x</span> and <span data-type="equation">y</span>) by a scalar. That is, <span data-type="equation">\vec{w} = \vec{u} * n</span> can be written as:</p>
<div data-type="equation">w_x = u_x * n</div>
<div data-type="equation">w_y = u_y * n</div>
<p>As an example, say <span data-type="equation">\vec{u} = (-3, 7)</span> and <span data-type="equation">n = 3</span>. You can calculate <span data-type="equation">\vec{w} = \vec{u} * n</span>as follows:</p>
<div data-type="equation">w_x = -3 * 3</div>
<div data-type="equation">w_y = 7 * 3</div>
<div data-type="equation">\vec{w} = (-9,21)</div>
<p>This is exactly how the <code>mult()</code> function inside the <code>p5.Vector</code> class works.</p>
<pre class="codesplit" data-code-language="javascript">mult(n) {
  //{!2} The components of the vector are multiplied by a number.
  this.x = this.x * n;
  this.y = this.y * n;
}</pre>
<p>Implementing multiplication in code is as simple as:</p><a data-type="indexterm" data-primary="mult() function (PVector class)" data-secondary="implementation"></a>
<pre class="codesplit" data-code-language="javascript">let u = vector(-3, 7);
// This p5.Vector is now three times the size and is equal to (-9, 21). (See Figure 1.9)
u.mult(3);</pre>
<p>Example 1.4 illustrates vector multiplication by drawing a line between the mouse and the center of the canvas, as in the previous example, and then scaling that line by 0.5.</p>
<div data-type="example">
  <h3 id="example-14-multiplying-a-vector">Example 1.4: Multiplying a vector</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/VQfwqpDlv" data-example-path="examples/01_vectors/example_1_4_vector_multiplication"><img src="examples/01_vectors/example_1_4_vector_multiplication/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">function draw() {
  background(255);

  let mouse = createVector(mouseX, mouseY);
  let center = createVector(width / 2, height / 2);
  mouse.sub(center);

  translate(width / 2, height / 2);
  strokeWeight(2);
  stroke(200);
  line(0, 0, mouse.x, mouse.y);

  //{!1} Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).
  mouse.mult(0.5);

  stroke(0);
  strokeWeight(4);
  line(0, 0, mouse.x, mouse.y);
}</pre>
<p>The resulting vector is half its original size. Rather than multiplying the vector by 0.5, I could also achieve the same effect by dividing the vector by 2, as in Figure 1.10.</p>
<figure>
  <img src="images/01_vectors/01_vectors_10.png" alt="Figure 1.10 Scaling a vector with division">
  <figcaption>Figure 1.10 Scaling a vector with division</figcaption>
</figure><a data-type="indexterm" data-primary="div() function (PVector class)"></a><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="div() function"></a>
<p>Vector division, then, works just like vector multiplication—just replace the multiplication sign (<code>*</code>) with the division sign (<code>/</code>). Here’s how the <code>p5.Vector</code> class implements the <code>div()</code> function:</p>
<pre class="codesplit" data-code-language="javascript">div(n) {
  this.x = this.x / n;
  this.y = this.y / n;
}
</pre>
<p>And here’s how to use the <code>div()</code> function in a sketch:</p>
<pre class="codesplit" data-code-language="javascript">div(n) {
  this.x = this.x / n;
  this.y = this.y / n;
}

let u = createVector(8, -4);
// Dividing a vector!  The vector is now half its original size (divided by 2).
u.div(2);</pre><a data-type="indexterm" data-primary="vectors" data-secondary="associative" data-tertiary="distributive rules for multiplication"></a>
<div data-type="note">
  <h3 id="more-number-properties-with-vectors">More Number Properties with Vectors</h3>
  <p>As with addition, basic algebraic rules of multiplication apply to vectors.</p>
  <p>The associative rule: <span data-type="equation">(n * m) * \vec{v} = n * (m * \vec{v})</span></p>
  <p>The distributive rule with 2 scalars, 1 vector: <span data-type="equation">(n + m) * \vec{v} = (n * \vec{v}) + (m * \vec{v})</span></p>
  <p>The distributive rule with 2 vectors, 1 scalar: <span data-type="equation">(\vec{u} + \vec{v}) * n = (\vec{u} * n) + (\vec{v} * n)</span></p>
</div>
<h2 id="15-vector-magnitude">1.5 Vector Magnitude</h2><a data-type="indexterm" data-primary="magnitude (of vectors)"></a><a data-type="indexterm" data-primary="vectors" data-secondary="magnitude"></a>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_11.png" alt=" Figure 1.11: The length or “magnitude” of a vector \vec{v} is often written as: \lVert\vec{v}\rVert">
  <figcaption>Figure 1.11: The length or “magnitude” of a vector <span data-type="equation">\vec{v}</span> is often written as: <span data-type="equation">\lVert\vec{v}\rVert</span></figcaption>
</figure>
<p>Multiplication and division, as just described, alter the length of a vector without affecting its direction. Perhaps you’re wondering: “OK, so how do I know what the length of a vector is? I know the components (<code>x</code> and <code>y</code>), but how long (in pixels) is the actual arrow?” Understanding how to calculate the length (also known as <strong><em>magnitude</em></strong>) of a vector is incredibly useful and important.</p><a data-type="indexterm" data-primary="Pythagoras"></a><a data-type="indexterm" data-primary="Pythagorean theorem"></a>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_12.png" alt="Figure 1.12: The Pythagorean Theorem is used to calculate the length of a vector from its components.">
  <figcaption>Figure 1.12: The Pythagorean Theorem is used to calculate the length of a vector from its components.</figcaption>
</figure>
<p>Notice in Figure 1.11 how the vector, drawn as an arrow and two components (<code>x</code> and <code>y</code>), creates a right triangle. The sides are the components and the hypotenuse is the arrow itself. We’re lucky to have this right triangle, because once upon a time, a Greek mathematician named Pythagoras discovered a lovely formula that describes the relationship between the sides and hypotenuse of a right triangle.</p>
<p>The Pythagorean theorem is <em>a</em> squared plus <em>b</em> squared equals <em>c</em> squared, for right triangles.</p>
<p>Armed with this formula, we can now compute the magnitude of <span data-type="equation">\vec{v}</span> as follows:</p>
<div data-type="equation">||\vec{v}||=\sqrt{v_x * v_x + v_y * v_y}</div>
<p>or in <code>p5.Vector</code>:</p>
<pre class="codesplit" data-code-language="javascript">mag() {
  return sqrt(this.x * this.x + this.y * this.y);
}</pre>
<div data-type="example">
  <h3 id="example-15-vector-magnitude">Example 1.5: Vector magnitude</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/rld_CtioUU" data-example-path="examples/01_vectors/example_1_5_vector_magnitude"><img src="examples/01_vectors/example_1_5_vector_magnitude/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div><a data-type="indexterm" data-primary="mag() function (PVector class)"></a><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="mag() function"></a>
<pre class="codesplit" data-code-language="javascript">function setup() {
  createCanvas(640, 240);
}

function draw() {
  background(255);

  let mouse = createVector(mouseX, mouseY);
  let center = createVector(width/2, height/2);
  mouse.sub(center);

  //{!3} The magnitude (i.e. length) of a vector can be accessed via the mag() function.  Here it is used as the width of a rectangle drawn at the top of the window.
  let m = mouse.mag();
  fill(0);
  rect(0, 0, m, 10);

  translate(width/2, height/2);
  line(0, 0, mouse.x, mouse.y);
}</pre>
<h2 id="16-normalizing-vectors">1.6 Normalizing Vectors</h2><a data-type="indexterm" data-primary="normalization"></a><a data-type="indexterm" data-primary="unit vectors"></a><a data-type="indexterm" data-primary="vectors" data-secondary="normalization"></a><a data-type="indexterm" data-primary="vectors" data-secondary="unit vectors"></a>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_13.png" alt="Figure 1.13 When a vector is normalized it points in the same direction but it is resized to a “unit” length of 1.">
  <figcaption>Figure 1.13 When a vector is normalized it points in the same direction but it is resized to a “unit” length of 1.</figcaption>
</figure>
<p>Calculating the magnitude of a vector is only the beginning. The <code>mag()</code> opens the door to many possibilities, the first of which is <strong><em>normalization</em></strong>. Normalizing refers to the process of making something “standard” or, well, “normal.” In the case of vectors, the convention is that a standard vector has a length of 1. To normalize a vector, therefore, is to take a vector of any length and, keeping it pointing in the same direction, change its length to 1. That vector is then called a <strong><em>unit vector</em></strong>.</p>
<p>A unit vector describes a vector’s direction without regard to its length. You’ll see this come in especially handy once I start to work with forces in Chapter 2.</p>
<p>For any given vector <span data-type="equation">\vec{u}</span> , its unit vector (written as <span data-type="equation">\hat{u}</span>) is calculated as follows:</p>
<div data-type="equation">\hat{u} = \frac{\vec{u}}{||\vec{u}||}</div>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_14.png" alt="Figure 1.14 To normalize a vector, the components are divided by the magnitude of a vector.">
  <figcaption>Figure 1.14 To normalize a vector, the components are divided by the magnitude of a vector.</figcaption>
</figure>
<p>In other words, to normalize a vector, divide each component by its magnitude. This is pretty intuitive. Say a vector is of length 5. Well, 5 divided by 5 is 1. So, looking at a right triangle, you then need to scale the hypotenuse down by dividing by 5. In that process the sides shrink, divided by 5 as well.</p><a data-type="indexterm" data-primary="normalize() function (PVector class)"></a><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="normalize() function"></a>
<p>In the <code>p5.Vector</code> class, the normalization method is written as follows:</p>
<pre class="codesplit" data-code-language="javascript">normalize() {
  let m = this.mag();
  this.div(m);
}</pre>
<p>Of course, there’s one small issue. What if the magnitude of the vector is 0? You can’t divide by 0! Some quick error checking will fix that right up:</p>
<pre class="codesplit" data-code-language="javascript">normalize() {
  let m = this.mag();
  if (m > 0) {
    this.div(m);
  }
}</pre>
<div data-type="example">
  <h3 id="example-16-normalizing-a-vector">Example 1.6: Normalizing a vector</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/5dWkegAID" data-example-path="examples/01_vectors/example_1_6_vector_normalize"><img src="examples/01_vectors/example_1_6_vector_normalize/screenshot.png"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">

function draw() {
  background(255);

  let mouse = createVector(mouseX, mouseY);
  let center = createVector(width / 2, height / 2);
  mouse.sub(center);

  translate(width / 2, height / 2);
  stroke(200);
  strokeWeight(2);
  line(0, 0, mouse.x, mouse.y);

  //{!2} In this example, after the vector is normalized, it is multiplied by 50. Note that no matter where the mouse is, the vector always has the same length (50) due to the normalization process.
  mouse.normalize();
  mouse.mult(50);

  stroke(0);
  strokeWeight(8);
  line(0, 0, mouse.x, mouse.y);
}</pre>
<h2 id="17-vector-motion-velocity">1.7 Vector Motion: Velocity</h2><a data-type="indexterm" data-primary="motion"></a><a data-type="indexterm" data-primary="vectors" data-secondary="velocity and"></a><a data-type="indexterm" data-primary="velocity"></a>
<p>All this vector math stuff sounds like something you should know about, but why? How will it actually help you write code? Patience. It will take some time before the awesomeness of using <code>p5.Vector</code> fully comes to light. This is a fairly common occurrence when learning a new data structure. For example, when you first learn about an array, it might seem like more work to use an array than to have several variables stand for multiple things. But that plan quickly breaks down when you need a hundred, or a thousand, or ten thousand things. The same can be true for vectors. What might seem like more work now will pay off later, and pay off quite nicely. And you don’t have to wait too long, as your reward will come in the next chapter.</p>
<p>For now, however, focus on <em>how</em> it works. What does it mean to program motion using vectors? You’ve seen the beginning of this in <a href="#example-12-bouncing-ball-with-vectors">Example 1.2</a>: the bouncing ball. The circle on screen has a position (where it is at any given moment) as well as a velocity (instructions for how it should move from one moment to the next). Velocity is added to position:</p>
<pre class="codesplit" data-code-language="javascript">position.add(velocity);</pre>
<p>And then the object is drawn at that position:</p>
<pre class="codesplit" data-code-language="javascript">circle(position.x, position.y, 48);</pre>
<p>This is Motion 101.</p>
<ol>
  <li><strong><em>Add velocity to position</em></strong></li>
  <li><strong><em>Draw object at position</em></strong></li>
</ol><a data-type="indexterm" data-primary="Processing" data-secondary="OOP online tutorial"></a>
<p>In the bouncing ball example, all of this code happened in within <code>setup()</code> and <code>draw()</code>. What I want to do now is move towards encapsulating all of the logic for motion inside of a <strong><em>class</em></strong>. This way, I can create a foundation for programming moving objects. In <a href="/introduction#i2-the-random-walker-class">section I.2 of the introduction</a>, “The Random Walker Class,” I briefly reviewed the basics of object-oriented-programming (“OOP”). Beyond that short introduction, this book assumes experience with objects and classes in JavaScript. If you need a refresher, I encourage you to check out the <a href="https://youtu.be/T-HGdc8L-7w">JavaScript classes video tutorial</a>.</p>
<p>To start, I’m going to create a generic <code>Mover</code> class that will describe a shape moving around the canvas. And so I must consider the following two questions:</p>
<ol>
  <li><strong><em>What data does a mover have?</em></strong></li>
  <li><strong><em>What functionality does a mover have?</em></strong></li>
</ol>
<p>The “Motion 101” algorithm provides the answers to these questions. A <code>Mover</code> object has two pieces of data: <code>position</code> and <code>velocity</code>, which are both <code>p5.Vector</code> objects. These are initialized in the object’s <strong><em>constructor</em></strong>. The constructor is a special function inside of a class that creates the instance of the object itself. It is where you give instructions on how to set up the object.</p>
<pre class="codesplit" data-code-language="javascript">class Mover {
  constructor(){
    this.position = createVector();
    this.velocity = createVector();
  }</pre>
<p>The functionality follows suit. The <code>Mover</code> needs to move and it needs to be visible. I’ll implement these needs as functions named <code>update()</code> and <code>show()</code>. I’ll put all of the motion logic code in <code>update()</code> and draw the object in <code>show()</code>.</p>
<pre class="codesplit" data-code-language="javascript">	update() {
	  //{!1} The Mover moves.
	  this.position.add(this.velocity);
	}
	
	show() {
	  stroke(0);
	  fill(175);
	  //{!1} The Mover is drawn as a circle.
	  circle(this.position.x, this.position.y, 48);
	}
}</pre><a data-type="indexterm" data-primary="class (Processing)" data-secondary="constructor"></a><a data-type="indexterm" data-primary="constructor"></a>
<p>I’ve forgotten one critical item, however. The <code>class</code> is not the object itself, it is a template for creating an instance of an object. The constructor makes the object when the code invokes the class name along with the <strong><em>new</em></strong> operator:</p>
<pre class="codesplit" data-code-language="javascript">  let mover = new Mover();</pre>
<p>In this case, let’s arbitrarily decide to initialize the <code>Mover</code> object by giving it a random position and a random velocity. Note the use of <code>this</code> with all variables that are part of the <code>Mover</code> object.</p>
<pre class="codesplit" data-code-language="javascript">  constructor() {
    this.position = createVector(random(width), random(height));
    this.velocity = createVector(random(-2,2), random(-2,2));
  }</pre>
<p>If object-oriented programming is at all new to you, one aspect here may seem a bit confusing. After all, I spent the beginning of this chapter discussing the <code>p5.Vector</code> class. The <code>p5.Vector</code> class is the template for making the <code>position</code> object and the <code>velocity</code> object. So what are they doing inside of yet another object, the <code>Mover</code> object? In fact, this is just about the most normal thing ever. An object is something that holds data (and functionality). That data can be numbers or other objects (arrays too)! You’ll see this over and over again in this book. For example, in <a href="/particles#41-why-you-need-particle-systems">Chapter 4</a> I’ll write a class to describe a system of particles. That <code>ParticleSystem</code> object will include a list of <code>Particle</code> objects…and each <code>Particle</code> object will have as its data several <code>p5.Vector</code> objects!</p>
<p>Let’s finish off the <code>Mover</code> class by incorporating a function to determine what the object should do when it reaches the edge of the canvas. For now let’s do something simple, and have it wrap around the edges.</p>
<pre class="codesplit" data-code-language="javascript">  checkEdges() {
    //{!11} When it reaches one edge, set position to the other.
    if (this.position.x > width) {
      this.position.x = 0;
    } else if (this.position.x &#x3C; 0) {
      this.position.x = width;
    }

    if (this.position.y > height) {
      this.position.y = 0;
    } else if (this.position.y &#x3C; 0) {
      this.position.y = height;
    }
  }</pre>
<p>Now that the <code>Mover</code> class is finished, I can move onto <code>setup()</code> and <code>draw()</code>. First, declare a <code>Mover</code> object:</p>
<pre class="codesplit" data-code-language="javascript">let mover;</pre>
<p>Then create and initialize the mover in <code>setup()</code>:</p>
<pre class="codesplit" data-code-language="javascript">mover = new Mover();</pre>
<p>and call the appropriate functions in <code>draw()</code>:</p>
<pre class="codesplit" data-code-language="javascript">mover.update();
mover.checkEdges();
mover.show();</pre>
<p>Here is the entire example for reference:</p>
<div data-type="example">
  <h3 id="example-17-motion-101-velocity">Example 1.7: Motion 101 (velocity)</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/6foX0NUfS" data-example-path="examples/01_vectors/example_1_7_motion_101_velocity"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">//{!1} Declare Mover object.
let mover;

function setup() {
  createCanvas(640, 240);
  //{!1} Create Mover object.
  mover = new Mover();
}

function draw() {
  background(255);

  //{!3} Call functions on Mover object.
  mover.update();
  mover.checkEdges();
  mover.show();
}</pre>
<pre class="codesplit" data-code-language="javascript">class Mover {

  constructor() {
    //{!2} The object has two vectors: position and velocity.
    this.position = createVector(random(width), random(height));
    this.velocity = createVector(random(-2, 2), random(-2, 2));
  }

  update() {
    //{!1} Motion 101: position changes by velocity.
    this.position.add(this.velocity);
  }

  show() {
    stroke(0);
    strokeWeight(2);
    fill(127);
    circle(this.position.x, this.position.y, 48);
  }

  checkEdges() {
    if (this.position.x > width) {
      this.position.x = 0;
    } else if (this.position.x &#x3C; 0) {
      this.position.x = width;
    }

    if (this.position.y > height) {
      this.position.y = 0;
    } else if (this.position.y &#x3C; 0) {
      this.position.y = height;
    }
  }
}</pre>
<h2 id="18-vector-motion-acceleration">1.8 Vector Motion: Acceleration</h2><a data-type="indexterm" data-primary="acceleration"></a><a data-type="indexterm" data-primary="vectors" data-secondary="acceleration"></a><a data-type="indexterm" data-primary="velocity" data-secondary="acceleration"></a>
<p>OK. At this point, you hopefully feel comfortable with two things: (1) what a vector is and (2) how to use vectors inside of an object to keep track of its position and movement. This is an excellent first step and deserves a mild round of applause. Before standing ovations and screaming fans, however, you need to make one more, somewhat bigger step forward. After all, watching the Motion 101 example is fairly boring—the circle never speeds up, never slows down, and never turns. For more sophisticated motion, for motion that appears in the real world around us, one more vector needs to be added to the class—<code>acceleration</code>.</p>
<p>The strict definition of <strong><em>acceleration</em></strong> I’m using here is: <em>the rate of change of velocity</em>. Think about that definition for a moment. Is this a new concept? Not really. Velocity is defined as <em>the rate of change of position</em>. In essence, I am developing a “trickle-down” effect. Acceleration affects velocity, which in turn affects position (for some brief foreshadowing, this point will become even more crucial in the next chapter, when I look at how forces affect acceleration, which affects velocity, which affects position). In code, this reads:</p>
<pre class="codesplit" data-code-language="javascript">velocity.add(acceleration);
position.add(velocity);</pre>
<p>As an exercise, from this point forward, I’m going to make a rule for myself. I will write every example in the rest of this book without ever touching the value of velocity and position (except to initialize them). In other words, the goal for programming motion is: Come up with an algorithm for how to calculate acceleration and let the trickle-down effect work its magic. (In truth, there will be a multitude of reasons to break this rule, and break it I shall. Nevertheless, it’s a useful constraint to begin with to illustrate the principles behind this motion algorithm.) The next step, then, is to come up with ways to calculate acceleration:</p>
<h3 id="acceleration-algorithms">Acceleration Algorithms!</h3><a data-type="indexterm" data-primary="acceleration" data-secondary="algorithms for"></a><a data-type="indexterm" data-primary="acceleration algorithms"></a>
<ol>
  <li><em>A constant acceleration</em></li>
  <li><em>A random acceleration</em></li>
  <li><em>Acceleration towards the mouse</em></li>
</ol><a data-type="indexterm" data-primary="acceleration algorithms" data-secondary="constant"></a>
<p>Algorithm #1, <em>a constant acceleration</em>, is not particularly interesting, but it is the simplest and an excellent starting point to incorporate acceleration into the code. The first thing to do is add another variable to the <code>Mover</code> class:</p>
<pre class="codesplit" data-code-language="javascript">class Mover {
  constructor(){
    this.position = createVector();
    this.velocity = createVector();
    //{!1 .bold} A new vector for acceleration
    this.acceleration = createVector();
  }</pre>
<p>And incorporate acceleration into the <code>update()</code> function:</p>
<pre class="codesplit" data-code-language="javascript">  update() {
    //{!2 .bold} The motion algorithm is now two lines of code!
    this.velocity.add(this.acceleration);
    this.position.add(this.velocity);
}</pre>
<p>I’re almost done. The only missing piece is initialization in the constructor.</p>
<pre class="codesplit" data-code-language="javascript">  constructor() {</pre>
<p>Let’s start the <code>Mover</code> object in the middle of the window…</p>
<pre class="codesplit" data-code-language="javascript">    this.position = createVector(width/2, height/2);</pre>
<p>…with an initial velocity of zero.</p>
<pre class="codesplit" data-code-language="javascript">    this.velocity = createVector(0, 0);</pre>
<p>This means that when the sketch starts, the object is at rest. I don’t have to worry about velocity anymore, as I am controlling the object’s motion entirely with acceleration. Speaking of which, according to Algorithm #1, the first sketch involves constant acceleration. So let’s pick a value.</p>
<pre class="codesplit" data-code-language="javascript">    this.acceleration = createVector(-0.001, 0.01);
  }</pre>
<p>Maybe you’re thinking, “Gosh, those values seem awfully small!” That’s right, they are quite tiny. Acceleration values (measured in pixels) accumulate over time in the velocity, about thirty times per second depending on the sketch’s frame rate. And so to keep the magnitude of the velocity vector within a reasonable range, the acceleration values should remain quite small. I can also manage this by incorporating the <code>p5.Vector</code> function <code>limit()</code>, putting a cap on the magnitude of velocity.</p><a data-type="indexterm" data-primary="limit() function (PVector class)"></a><a data-type="indexterm" data-primary="magnitude (of vectors)" data-secondary="limiting"></a><a data-type="indexterm" data-primary="PVector class (Processing)" data-secondary="limit() function"></a><a data-type="indexterm" data-primary="velocity" data-secondary="limiting"></a>
<pre class="codesplit" data-code-language="javascript">// The limit() function constrains the magnitude of a vector.
this.velocity.limit(10);</pre>
<p>This translates to the following:</p>
<p><em>What is the magnitude of velocity? If it’s less than 10, no worries; just leave it as is. If it’s more than 10, however, reduce it to 10!</em></p>
<div data-type="exercise">
  <h3 id="exercise-14">Exercise 1.4</h3>
  <p>Write the <code>limit()</code> function for the <code>p5.Vector</code> class.</p>
  <pre class="codesplit" data-code-language="javascript">  limit(max) {
    if (__________________ > __________________) {
      __________________();
      __________________(max);
    }
  }</pre>
</div>
<p>Let’s take a look at the changes to the <code>Mover</code> class, complete with <code>acceleration</code> and <code>limit()</code>.</p>
<div data-type="example">
  <h3 id="example-18-motion-101-velocity-and-constant-acceleration">Example 1.8: Motion 101 (velocity and constant acceleration)</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/4GSialOpQw" data-example-path="examples/01_vectors/example_1_8_motion_101_velocity_and_constant_acceleration"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">class Mover {

  constructor() {
    this.position = createVector(width/2, height/2);
    this.velocity = createVector(0, 0);
    // Acceleration is the key!
    this.acceleration = createVector(-0.001, 0.01);
    //{!1} The variable topspeed will limit the magnitude of velocity.
    this.topspeed = 10;
  }

  update() {
    //{!2} Velocity changes by acceleration and is limited by topspeed.
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.topspeed);
    this.position.add(this.velocity);
  }

  // show() is the same.
  show() {}

  //{!1} checkEdges() is the same.
  checkEdges() {}
}</pre>
<div data-type="exercise">
  <h3 id="exercise-15">Exercise 1.5</h3>
  <p>Create a simulation of an object (think about a vehicle?) that accelerates when you press the up key and brakes when you press the down key.</p>
</div><a data-type="indexterm" data-primary="acceleration algorithms" data-secondary="random"></a>
<p>Now on to Algorithm #2, <em>a random acceleration</em>. In this case, instead of initializing acceleration in the object’s constructor, I want to pick a new acceleration each cycle, i.e. each time <code>update()</code> is called.</p>
<div data-type="example">
  <h3 id="example-19-motion-101-velocity-and-random-acceleration">Example 1.9: Motion 101 (velocity and random acceleration)</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/w9DU8ccWMf" data-example-path="examples/01_vectors/example_1_9_motion_101_velocity_and_random_acceleration"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">  update() {

    //{!1} The random2D() function returns a unit vector pointing in a random direction.
    this.acceleration = p5.Vector.random2D();

    this.velocity.add(this.acceleration);
    this.velocity.limit(this.topspeed);
    this.position.add(this.velocity);
  }</pre>
<p>Because the random vector is a normalized one, I can try scaling it:</p>
<p>(a) scaling the acceleration to a constant value</p>
<pre class="codesplit" data-code-language="javascript">this.acceleration = p5.Vector.random2D();
//{.bold} Constant
this.acceleration.mult(0.5);</pre>
<p>(b) scaling the acceleration to a random value</p>
<pre class="codesplit" data-code-language="javascript">this.acceleration = p5.Vector.random2D();
//{.bold} Random
this.acceleration.mult(random(2));</pre>
<p>While this may seem like an obvious point, it’s crucial to understand that acceleration does not merely refer to the <em>speeding up</em> or <em>slowing down</em> of a moving object, but rather <em>any change</em> in velocity—magnitude or direction. Acceleration is used to steer an object, and you’ll see this again and again in future chapters as I begin to code objects that make decisions about how to move about the canvas.</p>
<div data-type="exercise">
  <h3 id="exercise-16">Exercise 1.6</h3>
  <p>Referring back to the <a href="/introduction#i6-perlin-noise-a-smoother-approach">Introduction</a>, implement an acceleration calculated with Perlin noise.</p>
</div>
<h2 id="19-static-vs-non-static-functions">1.9 Static vs. Non-Static Functions</h2><a data-type="indexterm" data-primary="functions" data-secondary="static vs. non-static"></a><a data-type="indexterm" data-primary="methods" data-secondary="static vs. non-static"></a><a data-type="indexterm" data-primary="Processing" data-secondary="static vs. non-static methods"></a>
<p>You might have noticed something a bit odd and unfamiliar in the previous example. The <code>random2D()</code> function used to create a random unit vector was called on the <code>p5.Vector</code> class name itself! This is what is known as a “static” function and is in a key concept underlying the <code>p5.Vector</code> class. Algorithm #3 (<em>accelerate towards the mouse</em>), in fact, requires further exploration of this concept: the difference between using <strong><em>static</em></strong> methods and <strong><em>non-static</em></strong> methods.</p>
<p>Forgetting about vectors for a moment, take a look at the following code:</p>
<pre class="codesplit" data-code-language="javascript">let x = 0;
let y = 5;

x = x + y;</pre>
<p>This is what you are probably used to, yes? <code>x</code> has the value of 0, add <code>y</code> to it, and now <code>x</code> is equal to 5. I could write the corresponding code for adding a vector based on what the previous examples where <code>velocity</code> was added to <code>position</code>.</p>
<pre class="codesplit" data-code-language="javascript">let v = createVector(0, 0);
let u = createVector(4, 5);
v.add(u);</pre>
<p>The vector <code>v</code> has the value of (0,0), I add <code>u</code> to it, and now <code>v</code> is equal to (4,5). Makes sense, right? Let’s take a look at another example of floating point math:</p>
<pre class="codesplit" data-code-language="javascript">let x = 0;
let y = 5;

let z = x + y;</pre>
<p><code>x</code> has the value of 0, I add <code>y</code> to it, and store the result in a new variable <code>z</code>. The value of <code>x</code> does not change in this example (neither does <code>y</code>)! This may seem like a trivial point, and one that is quite intuitive when it comes to mathematical operations with numbers. However, it’s not so obvious with mathematical operations using <code>p5.Vector</code>. Let’s try to rewrite the above code with vectors based on what I’ve covered so far.</p>
<pre class="codesplit" data-code-language="javascript">let v = createVector(0, 0);
let u = createVector(4, 5);
//{.line-through} Don’t be fooled; this is incorrect!!!
let w = v.add(u);</pre>
<p>The above might seem like a good guess, but it’s just not the way the <code>p5.Vector</code> class works. If you look at the definition of <code>add()</code> . . .</p>
<pre class="codesplit" data-code-language="javascript">add(v) {
  this.x = this.x + v.x;
  this.y = this.y + v.y;
}</pre>
<p>you‘ll see that this code does not accomplish my goal. First, it does not return a new <code>p5.Vector</code> object and second, it changes the value of the vector upon which it is called. In order to add two vector objects together and return the result as a new vector, I must use the static <code>add()</code> function.</p><a data-type="indexterm" data-primary="static functions"></a>
<p>Functions that are called from the class name itself (rather than from a speciﬁc object instance) are known as <strong><em>static</em></strong>. Here are two examples of function calls that assume two <code>p5.Vector</code> objects, <code>v</code> and <code>u</code>:</p>
<pre class="codesplit" data-code-language="javascript">// Static: called from the class name.
p5.Vector.add(v, u);

// Not static: called from an object instance.
v.add(u);</pre>
<p>When writing your own classes (like <code>Walker</code> or <code>Mover</code>), static functions are rarely needed, so it‘s likely you not have encountered them before. <code>p5.Vector</code>'s static functions generic mathematical operations to be performed on vectors without having to adjust the value of one of the input vectors. Let’s look at how I might write the static version of <code>add()</code>:</p>
<pre class="codesplit" data-code-language="javascript">  //{!1} The static version adds two vectors together and assigns the result to a new vector while leaving the original vectors (v and u above) intact.
  static add(v1, v2) {
    let v3 = createVector(v1.x + v2.x, v1.y + v2.y);
    return v3;
  }</pre>
<p>The key difference here is that the function creates a new vector (<code>v3</code>) and returns the sum of the components of <code>v1</code> and <code>v2</code> in <code>v3</code> without changing the values of either original vector.</p>
<p>When calling a static function, instead of referencing an object instance, you reference the name of the class itself.</p>
<pre class="codesplit" data-code-language="javascript">let v = createVector(0, 0);
let u = createVector(4, 5);
//{.line-through .no-comment}
let w = v.add(u);
//{.bold .no-comment}
let w = p5.Vector.add(v, u);</pre>
<p>The <code>p5.Vector</code> class has static versions of <code>add()</code>, <code>sub()</code>, <code>mult()</code>, and <code>div()</code>.</p>
<div data-type="exercise">
  <h3 id="exercise-17">Exercise 1.7</h3>
  <p>Translate the following pseudocode to code using static or non-static functions where appropriate.</p>
  <ul>
    <li>The vector <code>v</code> equals (1,5).</li>
    <li>The vector <code>u</code> equals <code>v</code> multiplied by 2.</li>
    <li>The vector <code>w</code> equals <code>v</code> minus <code>u</code>.</li>
    <li>Divide the vector w by 3.</li>
  </ul>
  <pre class="codesplit" data-code-language="javascript">let v = createVector(1, 5);
let u = ________.________(____,____);
let w = ________.________(____,____);
______________________;</pre>
</div>
<h2 id="110-interactivity-with-acceleration">1.10 Interactivity with Acceleration</h2><a data-type="indexterm" data-primary="acceleration algorithms" data-secondary="interactive"></a>
<p>To finish out this chapter, let’s try something a bit more complex and a great deal more useful. I’ll dynamically calculate an object’s acceleration according to a rule stated in Algorithm #3 — <em>the object accelerates towards the mouse</em>.</p>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_15.png" alt="Figure 1.15">
  <figcaption>Figure 1.15</figcaption>
</figure>
<p>Anytime you want to calculate a vector based on a rule or a formula, you need to compute two things: <strong><em>magnitude</em></strong> and <strong><em>direction</em></strong>. I’ll start with direction. I know the acceleration vector should point from the object’s position towards the mouse position. Let’s say the object is located at the position vector (<code>x</code>,<code>y</code>) and the mouse at (<code>mouseX</code>,<code>mouseY</code>).</p>
<figure class="half-width-right">
  <img src="images/01_vectors/01_vectors_16.png" alt="Figure 1.16">
  <figcaption>Figure 1.16</figcaption>
</figure>
<p>In Figure 1.16, you see that the vector (<code>dx</code>,<code>dy</code>) can be calculated by subtracting the object’s position from the mouse’s position.</p>
<ul>
  <li><span data-type="equation">dx = mouseX - x</span></li>
  <li><span data-type="equation">dy = mouseY - y</span></li>
</ul>
<p>Let’s rewrite the above using <code>p5.Vector</code> syntax. Assuming this code will live inside the <code>Mover</code> class and thus have access to the object’s <code>position</code>, I then have:</p>
<pre class="codesplit" data-code-language="javascript">let mouse = createVector(mouseX, mouseY);
// Look! I’m using the static reference to sub() because I want a new p5.Vector!
let dir = p5.Vector.sub(mouse, this.position);</pre>
<p>I now have a vector <code>dir</code> that points from the mover’s position all the way to the mouse. If the object were to actually accelerate using that vector, it would appear instantaneously at the mouse position. This does not make for a smooth animation, of course. The next step therefore is to decide how quickly that object should accelerate toward the mouse.</p>
<p>In order to set the magnitude (whatever it may be) of the acceleration vector, I must first _____<em>_</em> that direction vector. That’s right, you said it. <em>Normalize</em>. If I can shrink the vector down to its unit vector (of length one) then I can easily scale it to any value. One multiplied by anything equals anything.</p>
<pre class="codesplit" data-code-language="javascript">// Any number!
let anything = __________________;
dir.normalize();
dir.mult(anything);</pre>
<p>To summarize, take the following steps:</p>
<ol>
  <li>Calculate a vector that points from the object to the target position (mouse).</li>
  <li>Normalize that vector (reducing its length to 1).</li>
  <li>Scale that vector to an appropriate value (by multiplying it by some value).</li>
  <li>Assign that vector to acceleration.</li>
</ol>
<p>I have a confession to make. This is such a common operation (normalization then scaling) that <code>p5.Vector</code> includes a method to do just that—set the magnitude of a vector to a value. That function is <code>setMag()</code>.</p>
<pre class="codesplit" data-code-language="javascript">let anything = ?????
dir.setMag(anything);</pre>
<p>In this last example, to emphasize the math, I'm going to write the code using <code>normalize()</code> and <code>mult()</code>, but this is likely the last time I‘ll do that. You‘ll find <code>setMag()</code> in examples going forward.</p>
<div data-type="example">
  <h3 id="example-110-accelerating-towards-the-mouse">Example 1.10: Accelerating towards the mouse</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/gYJHm1EFL" data-example-path="examples/01_vectors/example_1_10_accelerating_towards_the_mouse"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">  update() {
    let mouse = createVector(mouseX, mouseY);
    // Step 1: Compute direction
    let dir = p5.Vector.sub(mouse, this.position);

    // Step 2: Normalize
    dir.normalize();

    // Step 3: Scale
    dir.mult(0.2);

    //{!1} Step 4: Accelerate
    this.acceleration = dir;

    this.velocity.add(this.acceleration);
    this.velocity.limit(this.topspeed);
    this.position.add(this.velocity);
  }</pre>
<p>You may be wondering why the circle doesn’t stop when it reaches the target. It’s important to note that the object moving has no knowledge about trying to stop at a destination; it only knows where the destination’s position. It tries to accelerate there at a fixed rate regardless of how far away it is. This means it will inevitably overshoot the target and have to turn around, again accelerating towards the destination, overshooting it again, and so on and so forth. Stay tuned; in later chapters I’ll show you how to program an object to <strong><em>arrive</em></strong> at a target (slow down on approach).</p>
<p>This example is remarkably close to the concept of gravitational attraction (here the object is <em>attracted</em> to the mouse position). Gravitational attraction will be covered in more detail in the next chapter. In this example, the attraction magnitude is contant. In gravity's case the magnitude is inversely proportional to distance. The closer the object is to the attractor, the faster it accelerates.</p>
<div data-type="exercise">
  <h3 id="exercise-18">Exercise 1.8</h3>
  <p>Try implementing the above example with a variable magnitude of acceleration, stronger when it is either closer or farther away.</p>
</div>
<p>While I would encourage you stop here and focus your experiments on experimenting with one (maybe 2?) objects in the canvas (Chapter 4 will cover systems of objects in greater detail), in case you can’t wait, here is what this example looks like with an array of movers.</p>
<div data-type="example">
  <h3 id="example-111-array-of-movers-accelerating-towards-the-mouse">Example 1.11: Array of movers accelerating towards the mouse</h3>
  <figure>
    <div data-type="embed" data-p5-editor="https://editor.p5js.org/natureofcode/sketches/IoNkw9uh6" data-example-path="examples/01_vectors/example_1_11_array_of_movers_accelerating_towards_the_mouse"></div>
    <figcaption></figcaption>
  </figure>
</div>
<pre class="codesplit" data-code-language="javascript">//{!1} An array of objects
let movers = [];

function setup() {
  createCanvas(640, 240);
  background(255);
  for (let i = 0; i &#x3C; 20; i++) {
    //{!1} Initialize each object in the array.
    movers[i] = new Mover();
  }
}

function draw() {
  background(255);

  for (int i = 0; i &#x3C; movers.length; i++) {
    //{!3} Calling functions on all the objects in the array
    movers[i].update();
    movers[i].show();
  }
}</pre>
<pre class="codesplit" data-code-language="javascript">class Mover {

  constructor() {
    this.position = createVector(random(width), random(height));
    this.velocity = createVector();
    this.acceleration = createVector();
    this.topspeed = 5;
  }

  update() {
    //{.comment-header} Algorithm for calculating acceleration:

    //{!2} Find the vector pointing towards the mouse.
    let mouse = createVector(mouseX, mouseY);
    let dir = p5.Vector.sub(mouse, this.position);
    //{!1} A constant magnitude
    dir.setMag(0.2);
    this.acceleration = dir;

    //{!3} Motion 101! Velocity changes by acceleration. position changes by velocity.
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.topspeed);
    this.position.add(this.velocity);
  }

  //{!1} Render the Mover
  show() {
    stroke(0);
    strokeWeight(2);
    //{!1) Adding some alpha transparency
    fill(127, 200);
    circle(this.position.x, this.position.y, 48);
  }

  //{!13} What to do at the edges
  checkEdges() {
    if (this.position.x > width) {
      this.position.x = 0;
    } else if (this.position.x > 0) {
      this.position.x = width;
    }

    if (this.position.y > height) {
      this.position.y = 0;
    } else if (this.position.y &#x3C; 0) {
      this.position.y = height;
    }
  }
}</pre>
<figure>
  <img src="images/01_vectors/01_vectors_17.png" alt="Figure 1.17: The Ecosystem Project">
  <figcaption>Figure 1.17: The Ecosystem Project</figcaption>
</figure>
<div data-type="project">
  <h3 id="the-ecosystem-project">The Ecosystem Project</h3>
  <p><em>As mentioned in the preface, one way to use this book is to build a single project over the course of reading it, incorporating elements from each chapter one at a time. One idea for this is a simulation of an ecosystem. Imagine a population of computational creatures swimming around a digital pond, interacting with each other according to various rules.</em></p>
  <p>Step 1 Exercise:</p>
  <p>Develop a set of rules for simulating the real-world behavior of a creature, such as a nervous fly, swimming fish, hopping bunny, slithering snake, etc. Can you control the object’s motion by only manipulating the acceleration vector? Try to give the creature a personality through its behavior (rather than through its visual design, although that is of course worth exploring as well).</p>
  <figure>
    <img src="images/01_vectors/01_vectors_18.png" alt="">
    <figcaption></figcaption>
  </figure>
</div>
</section>